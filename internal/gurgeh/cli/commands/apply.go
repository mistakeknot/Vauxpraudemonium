package commands

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"

	praudePlan "github.com/mistakeknot/autarch/internal/gurgeh/plan"
	"github.com/mistakeknot/autarch/internal/gurgeh/project"
	"github.com/mistakeknot/autarch/internal/gurgeh/specs"
	"github.com/mistakeknot/autarch/pkg/plan"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"
)

// ApplyCmd creates the apply command.
func ApplyCmd() *cobra.Command {
	var planFile string

	cmd := &cobra.Command{
		Use:   "apply",
		Short: "Apply a pending plan",
		Long: `Apply a pending plan generated by --plan flag.

By default, applies the most recent pending plan. Use --plan to specify
a specific plan file.

Examples:
  praude apply
  praude apply --plan .praude/pending/interview-plan.json
`,
		RunE: func(cmd *cobra.Command, args []string) error {
			root, err := os.Getwd()
			if err != nil {
				return err
			}
			out := cmd.OutOrStdout()

			var p *plan.Plan
			if planFile != "" {
				// Load specific plan file
				p, err = plan.Load(planFile)
				if err != nil {
					return fmt.Errorf("failed to load plan: %w", err)
				}
			} else {
				// Find pending plans
				plans, err := plan.ListPending(root, "praude")
				if err != nil {
					return fmt.Errorf("failed to list pending plans: %w", err)
				}
				if len(plans) == 0 {
					return fmt.Errorf("no pending plans found. Run a command with --plan first")
				}
				// Use the first one (most recent by convention)
				p, err = plan.Load(plans[0])
				if err != nil {
					return fmt.Errorf("failed to load plan: %w", err)
				}
			}

			// Check if plan is ready
			if !p.Ready {
				fmt.Fprintln(out, "Plan has errors that must be resolved:")
				for _, r := range p.FilterBySeverity(plan.SeverityError) {
					fmt.Fprintf(out, "  ✗ %s\n", r.Message)
					if r.Suggestion != "" {
						fmt.Fprintf(out, "    → %s\n", r.Suggestion)
					}
				}
				return fmt.Errorf("plan is not ready to apply")
			}

			// Show warnings
			if p.HasWarnings() {
				fmt.Fprintln(out, "Warnings:")
				for _, r := range p.FilterBySeverity(plan.SeverityWarning) {
					fmt.Fprintf(out, "  ⚠ %s\n", r.Message)
				}
				fmt.Fprintln(out)
			}

			// Apply based on action type
			switch p.Action {
			case "interview":
				return applyInterviewPlan(out, root, p)
			case "research":
				return applyResearchPlan(out, root, p)
			default:
				return fmt.Errorf("unknown plan action: %s", p.Action)
			}
		},
	}

	cmd.Flags().StringVar(&planFile, "plan", "", "Specific plan file to apply")
	return cmd
}

// applyInterviewPlan applies an interview plan to create a PRD.
func applyInterviewPlan(out io.Writer, root string, p *plan.Plan) error {
	var items praudePlan.InterviewPlanItems
	if err := p.GetItems(&items); err != nil {
		return fmt.Errorf("failed to parse plan items: %w", err)
	}

	// Build the spec from plan data
	spec := specs.Spec{
		ID:        items.PRD.ID,
		Title:     items.PRD.Title,
		Summary:   items.PRD.Problem,
		CreatedAt: p.CreatedAt.UTC().Format("2006-01-02T15:04:05Z07:00"),
		Requirements: items.PRD.Requirements,
		StrategicContext: specs.StrategicContext{
			CUJID:       "CUJ-001",
			CUJName:     "Primary Journey",
			MVPIncluded: true,
		},
		UserStory: specs.UserStory{
			Text: "As a user, " + items.PRD.Users + ", " + items.PRD.Problem,
			Hash: "pending",
		},
		CriticalUserJourneys: []specs.CriticalUserJourney{
			{
				ID:                 "CUJ-001",
				Title:              "Primary Journey",
				Priority:           "high",
				Steps:              []string{"Start", "Finish"},
				SuccessCriteria:    []string{"Goal achieved"},
				LinkedRequirements: []string{"REQ-001"},
			},
		},
	}

	// Write the spec
	specDir := project.SpecsDir(root)
	if err := os.MkdirAll(specDir, 0o755); err != nil {
		return err
	}

	raw, err := yaml.Marshal(spec)
	if err != nil {
		return err
	}

	specPath := filepath.Join(specDir, items.PRD.ID+".yaml")
	if err := os.WriteFile(specPath, raw, 0o644); err != nil {
		return err
	}

	fmt.Fprintf(out, "Created %s at %s\n", items.PRD.ID, specPath)

	// Validate
	res, err := specs.Validate(raw, specs.ValidationOptions{Mode: specs.ValidationSoft, Root: root})
	if err != nil {
		fmt.Fprintf(out, "Validation error: %v\n", err)
	} else if len(res.Warnings) > 0 {
		fmt.Fprintln(out, "Validation warnings:")
		for _, w := range res.Warnings {
			fmt.Fprintf(out, "  - %s\n", w)
		}
	}

	// Clear the pending plan
	if err := plan.ClearPending(root, "praude", "interview"); err != nil {
		fmt.Fprintf(out, "Warning: failed to clear pending plan: %v\n", err)
	}

	return nil
}

// applyResearchPlan applies a research plan.
func applyResearchPlan(out io.Writer, root string, p *plan.Plan) error {
	var items praudePlan.ResearchPlanItems
	if err := p.GetItems(&items); err != nil {
		return fmt.Errorf("failed to parse plan items: %w", err)
	}

	fmt.Fprintf(out, "Research plan for %s would be applied here\n", items.SpecID)
	fmt.Fprintln(out, "(Research plan application not yet implemented)")

	// Clear the pending plan
	if err := plan.ClearPending(root, "praude", "research"); err != nil {
		fmt.Fprintf(out, "Warning: failed to clear pending plan: %v\n", err)
	}

	return nil
}

// Silence unused import warnings
var _ = json.Marshal

package cli

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/signal"
	"strings"
	"syscall"

	"github.com/spf13/cobra"

	"github.com/mistakeknot/autarch/internal/pollard/config"
	"github.com/mistakeknot/autarch/internal/pollard/hunters"
	pollardPlan "github.com/mistakeknot/autarch/internal/pollard/plan"
	"github.com/mistakeknot/autarch/internal/pollard/proposal"
	"github.com/mistakeknot/autarch/internal/pollard/reports"
	"github.com/mistakeknot/autarch/internal/pollard/sources"
	"github.com/mistakeknot/autarch/internal/pollard/state"
	"github.com/mistakeknot/autarch/pkg/plan"
)

var applyPlanFile string

var applyCmd = &cobra.Command{
	Use:   "apply",
	Short: "Apply a pending plan",
	Long: `Apply a pending plan generated by --plan flag.

By default, applies the most recent pending plan. Use --plan to specify
a specific plan file.

Examples:
  pollard apply
  pollard apply --plan .pollard/pending/scan-plan.json
`,
	RunE: func(cmd *cobra.Command, args []string) error {
		cwd, err := os.Getwd()
		if err != nil {
			return err
		}

		var p *plan.Plan
		if applyPlanFile != "" {
			p, err = plan.Load(applyPlanFile)
			if err != nil {
				return fmt.Errorf("failed to load plan: %w", err)
			}
		} else {
			plans, err := plan.ListPending(cwd, "pollard")
			if err != nil {
				return fmt.Errorf("failed to list pending plans: %w", err)
			}
			if len(plans) == 0 {
				return fmt.Errorf("no pending plans found. Run a command with --plan first")
			}
			p, err = plan.Load(plans[0])
			if err != nil {
				return fmt.Errorf("failed to load plan: %w", err)
			}
		}

		// Check if plan is ready
		if !p.Ready {
			fmt.Println("Plan has errors that must be resolved:")
			for _, r := range p.FilterBySeverity(plan.SeverityError) {
				fmt.Printf("  ✗ %s\n", r.Message)
				if r.Suggestion != "" {
					fmt.Printf("    → %s\n", r.Suggestion)
				}
			}
			return fmt.Errorf("plan is not ready to apply")
		}

		// Show warnings
		if p.HasWarnings() {
			fmt.Println("Warnings:")
			for _, r := range p.FilterBySeverity(plan.SeverityWarning) {
				fmt.Printf("  ⚠ %s\n", r.Message)
			}
			fmt.Println()
		}

		// Apply based on action type
		switch p.Action {
		case "scan":
			return applyScanPlan(cwd, p)
		case "report":
			return applyReportPlan(cwd, p)
		case "propose":
			return applyProposePlan(cwd, p)
		default:
			return fmt.Errorf("unknown plan action: %s", p.Action)
		}
	},
}

func applyScanPlan(cwd string, p *plan.Plan) error {
	var items pollardPlan.ScanPlanItems
	if err := p.GetItems(&items); err != nil {
		return fmt.Errorf("failed to parse plan items: %w", err)
	}

	cfg, err := config.Load(cwd)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	if err := sources.EnsureDirectories(cwd); err != nil {
		return fmt.Errorf("failed to create directories: %w", err)
	}

	db, err := state.Open(cwd)
	if err != nil {
		return fmt.Errorf("failed to open state database: %w", err)
	}
	defer db.Close()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-sigCh
		fmt.Println("\nInterrupted, stopping hunters...")
		cancel()
	}()

	registry := hunters.DefaultRegistry()

	for _, hp := range items.Hunters {
		if !hp.Enabled {
			continue
		}

		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
		}

		hunter, ok := registry.Get(hp.ID)
		if !ok {
			fmt.Printf("Warning: hunter %q not found in registry, skipping\n", hp.ID)
			continue
		}

		hunterCfg, _ := cfg.GetHunterConfig(hp.ID)
		fmt.Printf("Running hunter: %s\n", hp.Name)

		runID, err := db.StartRun(hp.ID)
		if err != nil {
			fmt.Printf("  Warning: failed to record run start: %v\n", err)
		}

		hCfg := hunters.HunterConfig{
			Queries:     hunterCfg.Queries,
			MaxResults:  hunterCfg.MaxResults,
			MinStars:    hunterCfg.MinStars,
			MinPoints:   hunterCfg.MinPoints,
			Categories:  hunterCfg.Categories,
			OutputDir:   hunterCfg.Output,
			ProjectPath: cwd,
		}

		for _, t := range hunterCfg.Targets {
			hCfg.Targets = append(hCfg.Targets, hunters.CompetitorTarget{
				Name:      t.Name,
				Changelog: t.Changelog,
				Docs:      t.Docs,
				GitHub:    t.GitHub,
			})
		}

		result, err := hunter.Hunt(ctx, hCfg)
		if err != nil {
			fmt.Printf("  Error: %v\n", err)
			if runID > 0 {
				db.CompleteRun(runID, false, 0, 0, err.Error())
			}
			continue
		}

		success := result.Success()
		errMsg := ""
		if !success && len(result.Errors) > 0 {
			errMsg = result.Errors[0].Error()
		}
		if runID > 0 {
			db.CompleteRun(runID, success, result.SourcesCollected, result.InsightsCreated, errMsg)
		}

		fmt.Printf("  %s\n", result.String())
		if len(result.OutputFiles) > 0 {
			fmt.Printf("  Output files:\n")
			for _, f := range result.OutputFiles {
				fmt.Printf("    - %s\n", f)
			}
		}
	}

	// Clear the pending plan
	if err := plan.ClearPending(cwd, "pollard", "scan"); err != nil {
		fmt.Printf("Warning: failed to clear pending plan: %v\n", err)
	}

	return nil
}

func applyReportPlan(cwd string, p *plan.Plan) error {
	var items pollardPlan.ReportPlanItems
	if err := p.GetItems(&items); err != nil {
		return fmt.Errorf("failed to parse plan items: %w", err)
	}

	generator := reports.NewGenerator(cwd)

	var rType reports.ReportType
	switch items.ReportType {
	case "landscape":
		rType = reports.TypeLandscape
	case "competitive":
		rType = reports.TypeCompetitive
	case "trends":
		rType = reports.TypeTrends
	case "research":
		rType = reports.TypeResearch
	default:
		rType = reports.TypeLandscape
	}

	filePath, err := generator.Generate(rType)
	if err != nil {
		return fmt.Errorf("failed to generate report: %w", err)
	}

	fmt.Printf("Report generated: %s\n", filePath)

	// Clear the pending plan
	if err := plan.ClearPending(cwd, "pollard", "report"); err != nil {
		fmt.Printf("Warning: failed to clear pending plan: %v\n", err)
	}

	return nil
}

func applyProposePlan(cwd string, p *plan.Plan) error {
	var items pollardPlan.ProposePlanItems
	if err := p.GetItems(&items); err != nil {
		return fmt.Errorf("failed to parse plan items: %w", err)
	}

	// Create scanner and scan for context
	scanner := proposal.NewContextScanner(cwd)
	var ctx *proposal.ProjectContext
	var err error

	if items.IncludeSrc {
		ctx, err = scanner.ScanWithSrc()
	} else {
		ctx, err = scanner.Scan()
	}
	if err != nil {
		return fmt.Errorf("failed to scan project: %w", err)
	}

	fmt.Printf("Scanning project: %s\n", ctx.ProjectName)
	if len(ctx.Files) == 0 {
		return fmt.Errorf("no documentation files found")
	}
	fmt.Printf("Found %d documentation file(s): %s\n", len(ctx.Files), strings.Join(items.FilesFound, ", "))

	// Create interruptible context
	runCtx, cancel := context.WithCancel(context.Background())
	defer cancel()

	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-sigCh
		fmt.Println("\nInterrupted...")
		cancel()
	}()

	// Create generator with config from plan
	cfg := proposal.DefaultConfig()
	cfg.MaxAgendas = items.MaxAgendas
	cfg.IncludeSrc = items.IncludeSrc
	generator := proposal.NewAgendaGeneratorWithConfig(cfg)

	fmt.Println("Invoking AI agent to propose research agendas...")
	result, err := generator.Generate(runCtx, ctx)
	if err != nil {
		return fmt.Errorf("failed to generate proposals: %w", err)
	}

	// Save results
	if err := proposal.SaveResult(cwd, result); err != nil {
		return fmt.Errorf("failed to save proposals: %w", err)
	}

	// Display results
	fmt.Printf("\nGenerated %d research agenda(s):\n\n", len(result.Agendas))
	for i, agenda := range result.Agendas {
		fmt.Printf("%d. %s [%s] (%s priority)\n", i+1, agenda.Title, agenda.ID, agenda.Priority)
		fmt.Printf("   %s\n", agenda.Description)
		if len(agenda.Questions) > 0 {
			fmt.Printf("   Questions: %d\n", len(agenda.Questions))
		}
		if len(agenda.SuggestedHunters) > 0 {
			fmt.Printf("   Hunters: %s\n", strings.Join(agenda.SuggestedHunters, ", "))
		}
		fmt.Println()
	}

	// Clear the pending plan
	if err := plan.ClearPending(cwd, "pollard", "propose"); err != nil {
		fmt.Printf("Warning: failed to clear pending plan: %v\n", err)
	}

	fmt.Println("Proposals saved to .pollard/proposals/current.yaml")
	fmt.Println("Run 'pollard propose --select' to choose which agendas to pursue")

	return nil
}

func init() {
	applyCmd.Flags().StringVar(&applyPlanFile, "plan", "", "Specific plan file to apply")
	rootCmd.AddCommand(applyCmd)
}

// Silence unused import
var _ = json.Marshal

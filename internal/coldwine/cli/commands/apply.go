package commands

import (
	"encoding/json"
	"fmt"
	"io"
	"strings"

	"github.com/spf13/cobra"

	"github.com/mistakeknot/autarch/internal/coldwine/epics"
	tandemoniumPlan "github.com/mistakeknot/autarch/internal/coldwine/plan"
	"github.com/mistakeknot/autarch/internal/coldwine/project"
	"github.com/mistakeknot/autarch/pkg/plan"
)

// ApplyCmd creates the apply command.
func ApplyCmd() *cobra.Command {
	var planFile string
	var existingMode string

	cmd := &cobra.Command{
		Use:   "apply",
		Short: "Apply a pending plan",
		Long: `Apply a pending plan generated by --plan flag.

By default, applies the most recent pending plan. Use --plan to specify
a specific plan file.

Examples:
  tandemonium apply
  tandemonium apply --plan .tandemonium/pending/init-plan.json
  tandemonium apply --existing overwrite
`,
		RunE: func(cmd *cobra.Command, args []string) error {
			root, err := project.FindRoot(".")
			if err != nil {
				root = "."
			}
			out := cmd.OutOrStdout()

			var p *plan.Plan
			if planFile != "" {
				p, err = plan.Load(planFile)
				if err != nil {
					return fmt.Errorf("failed to load plan: %w", err)
				}
			} else {
				plans, err := plan.ListPending(root, "tandemonium")
				if err != nil {
					return fmt.Errorf("failed to list pending plans: %w", err)
				}
				if len(plans) == 0 {
					return fmt.Errorf("no pending plans found. Run a command with --plan first")
				}
				p, err = plan.Load(plans[0])
				if err != nil {
					return fmt.Errorf("failed to load plan: %w", err)
				}
			}

			// Check if plan is ready
			if !p.Ready {
				fmt.Fprintln(out, "Plan has errors that must be resolved:")
				for _, r := range p.FilterBySeverity(plan.SeverityError) {
					fmt.Fprintf(out, "  ✗ %s\n", r.Message)
					if r.Suggestion != "" {
						fmt.Fprintf(out, "    → %s\n", r.Suggestion)
					}
				}
				return fmt.Errorf("plan is not ready to apply")
			}

			// Show warnings
			if p.HasWarnings() {
				fmt.Fprintln(out, "Warnings:")
				for _, r := range p.FilterBySeverity(plan.SeverityWarning) {
					fmt.Fprintf(out, "  ⚠ %s\n", r.Message)
				}
				fmt.Fprintln(out)
			}

			// Apply based on action type
			switch p.Action {
			case "init":
				return applyInitPlan(out, root, p, existingMode)
			default:
				return fmt.Errorf("unknown plan action: %s", p.Action)
			}
		},
	}

	cmd.Flags().StringVar(&planFile, "plan", "", "Specific plan file to apply")
	cmd.Flags().StringVar(&existingMode, "existing", "skip", "Existing epic handling (skip|overwrite)")
	return cmd
}

// applyInitPlan applies an init plan to create epics.
func applyInitPlan(out io.Writer, root string, p *plan.Plan, existingMode string) error {
	var items tandemoniumPlan.InitPlanItems
	if err := p.GetItems(&items); err != nil {
		return fmt.Errorf("failed to parse plan items: %w", err)
	}

	// Initialize the .tandemonium directory
	if err := project.Init("."); err != nil {
		return err
	}

	// Find root after init
	root, err := project.FindRoot(".")
	if err != nil {
		return err
	}

	// Convert plan epics to epics.Epic
	var epicList []epics.Epic
	for _, ep := range items.Epics {
		e := epics.Epic{
			ID:     ep.ID,
			Title:  ep.Title,
			Status: epics.Status(ep.Status),
		}
		if e.Status == "" {
			e.Status = epics.StatusTodo
		}
		for _, sp := range ep.Stories {
			e.Stories = append(e.Stories, epics.Story{
				ID:                 sp.ID,
				Title:              sp.Title,
				Status:             epics.StatusTodo,
				AcceptanceCriteria: sp.AcceptanceCriteria,
			})
		}
		epicList = append(epicList, e)
	}

	fmt.Fprintf(out, "Creating %d epic(s) from %s\n", len(epicList), items.SourcePRD)

	specsDir := project.SpecsDir(root)

	var writeOpts epics.WriteOptions
	switch strings.ToLower(existingMode) {
	case "overwrite":
		writeOpts.Existing = epics.ExistingOverwrite
	default:
		writeOpts.Existing = epics.ExistingSkip
	}

	if err := epics.WriteEpics(specsDir, epicList, writeOpts); err != nil {
		return fmt.Errorf("failed to write epics: %w", err)
	}

	for _, e := range epicList {
		fmt.Fprintf(out, "  - %s: %s (%d stories)\n", e.ID, e.Title, len(e.Stories))
	}

	fmt.Fprintf(out, "Wrote epics to %s\n", specsDir)

	// Clear the pending plan
	if err := plan.ClearPending(root, "tandemonium", "init"); err != nil {
		fmt.Fprintf(out, "Warning: failed to clear pending plan: %v\n", err)
	}

	return nil
}

// Silence unused import
var _ = json.Marshal
